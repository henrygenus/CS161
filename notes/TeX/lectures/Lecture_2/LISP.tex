\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}

\begin{itemize} [itemsep=0mm]
	\item is one of the oldest languages (1958)
	\item is the second high level language developed (behind FORTRAN (1957))
	\item was introduced for symbolic manipulation
	\item is a functional language
	\item has a uniform and simple syntax
\end{itemize} \medskip

\noindent Upon starting the LISP IDE, the user sees a listener (>).\\
The user then gives a LISP expression of the form:
\begin{lstlisting} [language=Lisp]
    (op arg1 ... argn) ; where op is a function name or special operator
\end{lstlisting} \medskip

\noindent Types of expressions:
\begin{enumerate}
\item Numeric Expressions
\item Symbolic Expressions
\item Boolean Expressions
\end{enumerate}

\noindent Other Material:
\begin{enumerate}
\item Branching 
\item Function Definition
\end{enumerate}
\noindent and that is LISP!\\
\
Lisp uses prefix notation for operations:
\begin{lstlisting} [language=Lisp]
	; Mixing of types in an expression is allowed:
	> (+ 2.7 10)
	> 12. 7
	; There is no limit on the argument count
	> (+ 21 35 12 7)
	> 75
	; Expressions can be recursive
	> (+ (* 3 51) (- 10 6))
	> 19
\end{lstlisting} \medskip

\noindent We introduce two special operators:
\begin{enumerate} 
\item The quote operator gets an expression without evaluation.\\
	We use this since sometimes lists represent data rather than expressions.
\begin{lstlisting} [language=Lisp]
	> (quote (+ 3 1))
	> (+ 3 1)
	; this can also be written "> '(+ 3 1)"
\end{lstlisting}
\item The setq operator assigns a value to a variable.
\begin{lstlisting} [language=Lisp]
	> (setq x 3)
	> 3
	> (setq y (+ 1 3))
	> y
	> 4
	; we can use this to bind an expression to a variable
	> (setq z '(+ 1 3))
	> (+ 1 3)
	; expressions in expressions are evaluated
	> (setq z y)
	> 4
\end{lstlisting}
\end{enumerate} \medskip

\noindent More generally, a LISP expression is either
\begin{enumerate}
\item an atom (number, symbol, string, etc)
\item a list (>= 0 expressions)
\end{enumerate} \medskip

\noindent A common way to use lists/expression is to represent data; we then need:
\begin{enumerate}
\item accessors (car, cdr) = (first, rest)
\item constructors (cons, list)
\end{enumerate}
\noindent The accessors car and cdr behave as follows:
\begin{lstlisting} [language=Lisp]
	> (setq x '(a b c d)) // this would be an error without the quote
	> (a b c d)
	; car (or first) gives the first item in a list
	> (car x)
	> a
	; cdr (or rest) gives the rest of the list
	> (cdr x)
	> (b c d)
	; how would I print the second element?
	> (car (cdr x)) // shorthand: (cadr x)
	> b
	; we can recurse indefinitely here
	> (caddr x)
	> c
\end{lstlisting}
The empty list is denoted “NIL” and evaluates to false.\\
NIL functions expectedly with car/cdr
\begin{lstlisting} [language=Lisp]
	> (car NIL)
	> NIL
	> (cdr NIL)
	> NIL
	> (cdr '(c))
	> NIL
\end{lstlisting}

\noindent The constructors list and cons behave as follows:\\
\begin{lstlisting} [language=Lisp]
	; list joins the following elements
	> (list 1 2 3)
	> (1 2 3)
	; cons joins the two parameters, such that arg1=car \& arg2=cdr
	> (cons 'a '(b c))
	> (a b c)
	> (cons (+ 1 2) '(b c))
	> (3 b c)
	> (cons 'a NIL)
	> (a)
	> (cons '(a b) '(c d))
	> ((a b) c d)
	> (cons 1 (cond 2 NIL))
	> (1 2)
\end{lstlisting} \medskip

\noindent Boolean expressions use NIL for false and t for true
\begin{lstlisting} [language=Lisp]
	> (> 3 1)
	> t
	> (< 3 1)
	> NIL
	; listp evaluates type of element
	> (not (listp 3))
	> t
	> (listp '(a b))
	> t
	; there is an =NIL operator 'null'
	> (null (cdr '(2)))
	> t
	; note that it uses the most recent true value for return
	> (OR NIL 3)
	> 3
	> (OR NIL (cdr '(c)) 7)
	> 7
\end{lstlisting} \medskip

\noindent We can evaluate equality in one of three ways:\\
\begin{itemize}
	\item '=' compares integers
	\item 'equal' compares elements (or direct values)
    	\item 'eqL' compares underlying pointers
\end{itemize} \medskip

\noindent Now onto the big stuff……
\subsection*{Functions}
\begin{lstlisting} [language=Lisp]
	> (defun name (parameters)
	      operations))
\end{lstlisting} \medskip

\noindent A very simple function to start with is the “square” function
\begin{lstlisting} [language=Lisp]
	> (defun square (x)
	      (* x x))
	> (square 3)
	> 9
\end{lstlisting} \medskip

\noindent We can use the “cond” keyword to emulate a switch
\begin{lstlisting} [language=Lisp]
	> (defun odd (x)
	      (cond ((= x 0) NIL)
		((= x 1) t)
		(t (odd (- x 2)))))
\end{lstlisting} \medskip

\noindent In Lisp, we tend to write functions that fall into one of three types:
\begin{enumerate}
	\item numeric (as above)
	\item list
	\begin{enumerate}
		\item use accessors
		\item use constructors
	\end{enumerate}
\end{enumerate} \medskip

\noindent A quick note on numeric functions:
\begin{lstlisting} [language=Lisp]
	; we bind variables with the keyword "let
	> (defun foo (x y)
	      (let ((a (+ x y))
		(b (* x y)))
		(/ a b)))
	; this binding is local to the scope of the operation
	> (setq x 5)
	> (+ (let ((x 3)) (+ x (* x 10))) x)
	> 38
	; binding is done in parallel
	> (setq x 2)
	> (let ((a (+ x -1))
	      (b (+ a 3)}
	; GIVES AN ERROR: let* binds in series \& would allow the above:
	> (let ((x 3) (y (+ x 2))) (x + y)
	> 12
	> (let* ((x 3) (y (+ x 2))) (x + y)
	> 15
\end{lstlisting} \medskip

\noindent We consider some accessor functions:
\begin{enumerate}
\item compute the sum of all the elements of a list:
\begin{lstlisting} [language=Lisp]
	> (defun sumlist (L)
	(cond ((null L) 0)
	  (t (+ (first L) (sumlist (rest L)}
	; a curly brace denotes "close all paren"
	> (sumlist `(1 2 3))
	> 6
\end{lstlisting}
\item determine whether an element is a member of a list:
\begin{lstlisting} [language=Lisp]
	> (defun member (x L)
	      (cond ((null t) NIL)
		((equal x (first L)) t)
		(t (member x (rest L)}
	> (member NIL `(a b))
	> NIL
	> (member `(a b) `(1 7 (a b) d))
	> t
\end{lstlisting}
\item return the last element in a list
\begin{lstlisting} [language=Lisp]
	> (defun last (L)
	      (cond ((null (rest L)) (first L))
		(t (last (rest L)}
\end{lstlisting} \medskip
\end{enumerate} 

\noindent We consider some constructor functions:
\begin{enumerate}
\item remove one occurrence of an element from a list 
\begin{lstlisting} [language=Lisp]
	> (defun remove (elm list)
	      (cond ((null list) NIL)
		((equal elm (first list)) (rest list)
		(t (cons (first list) (remove elm (rest list)}
\end{lstlisting}
\item append a list to another
\begin{lstlisting} [language=Lisp]
	> (defun append (L1 L2)
	      (cond ((null (last L2)) L2)
		(t (cons (first L2) (append L1 (rest L2)}
\end{lstlisting}
\item reverse a list
\begin{lstlisting} [language=Lisp]
	> (defun reverse (L)
	      (cond ((null L) NIL)
		((null (rest L) (first L))
		(t (append (reverse (rest L) (first L)}
\end{lstlisting}
\end{enumerate}

\end{document}