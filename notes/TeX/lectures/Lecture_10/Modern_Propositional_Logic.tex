\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}

\subsection*{Reducing Queries to SAT}
\noindent Consider the sentence $\Delta = (A \lor B \lor \neg C) \land (\neg A \lor C) \land (A \land C \land \neg D)$\\
We treat each clause as a constraint, and solve as a CSP\\
\indent $\rightarrow \text{ if } w = \{A=T, B=F, C=T, D=F\}, \text{ then } w \models \Delta$\\
\\
Thus we can see why SAT is the prototypical NP-Complete problem.\\
We will now discuss various methods to solve SAT problems.
 
\subsubsection*{Sat Solvers}
\noindent There are two ways to solve SAT problems that are considered standard:
\begin{enumerate} [itemsep=0mm]
	\item Backtrack Search (DFS + Failure Detection)
	\item Local Search (Very Fast, Incomplete Search)
 \end{enumerate}
\noindent In the context of SAT, backtrack search is called DPLL (initials of the 4 creators).\\
There are a few tools commonly used to make DPLL faster.
\begin{enumerate} [itemsep=0mm]
	\item uses a degree heuristic to determine value ordering
	\item can learn from the past via conflict clause learning
	\item can perform component analysis to break problems down
	\item utilizes random restarts 
	\item utilizes unit resolution (resolution with a single term clause — linear \& incomplete)
\end{enumerate}

\noindent Local Search is much simpler and faster, but incomplete.
\begin{enumerate} [itemsep=0mm]
	\item Guess a truth assignment
	\item check whether the rule holds.\\
		YES $\rightarrow$ DONE
		NO $\rightarrow$ try again
\end{enumerate}

\begin{center} \begin{tikzpicture}
	\node [align=center] (1)  {\begin{tabular} { | c | c | c | c |}
						\hline & & & \\\hline & x & & x \\\hline x & & x & \\\hline  & & & \\\hline \end{tabular}};
	\node [align=center, right =of 1] (2) {\begin{tabular} { | c | c | c | c |} 
						\hline & x & & \\\hline & & & x \\\hline x & & x & \\\hline & & & \\\hline \end{tabular}};
	\node [align=center, right =of 2] (3)  {\begin{tabular} { | c | c | c | c |} 
						\hline & & & \\\hline & x & & x \\\hline x & & & \\\hline & & x & \\\hline \end{tabular}};
	\node[below=0cm of 1] {N=5};
	\node[below=0cm of 2] {N=2};
	\node[below=0cm of 3] {N=0};
	\draw [->] (1.east) -- (2.west);
	\draw [->] (2.east) -- (3.west);
\end{tikzpicture}\end{center} 

\noindent It turns out that the N queens problem is simple for local search;\\
\indent This is because the solutions are densely distributed.\\
\\
Solutions are densely distributed when a problem is \textbf{\underline{under-constrained}}.\\
Solutions are sparsely distributed when a problem is \textbf{\underline{over-constrained}}.\\
The hardest problems tend to be at the threshold of the two.

\subsubsection*{1. Hill Climbing}
\noindent The difficulty of these algorithms comes in the way we determine what truth assignment to use.\\
There are two standard approaches to this:
We can imagine the complete assignments in a graph.\\

\begin{center} \begin{minipage} {0.8\textwidth}
\textbf{\underline{Hill-climbing}} is choosing the next node by heuristic.\\
We have two major issues:
	\begin{itemize} [itemsep=0mm]
		\item local extrema\\
			solution: utilize random restarts
		\item side-moves
			solution: consecutive side-move limits
	\end{itemize}
Our algorithm therefore takes the form of an embedded loop.\\
\noindent There is no guarantee this visits every world; we have two choices to deal with this:
\begin{enumerate} [itemsep=0mm]
	\item allow the algorithm to complete — complete but can loop infinitely
	\item terminate after a time limit — incomplete
\end{enumerate}
\end{minipage}% 
\begin{minipage}{0.2\textwidth}\begin{tikzpicture}
	\node [circle, draw] (1) {};
	\node [circle, draw, below right =of 1] (2) {};
	\node [circle, draw, above right =of 2] (3) {};
	\node [circle, draw, below =of 3] (4) {};
	\node [circle, draw, right =of 4] (5) {};
	\node [circle, draw, below =of 5] (6) {};
	\draw [-] (1.east) -- (3.west);
	\draw [-] (2.south) -- (6.west);
	\draw [-] (4.east) -- (5.west);
	\draw [-] (2.east) -- (4.west);
	\draw [-] (4.south) -- (6.north);
	\draw [-] (4.north) -- (3.west);
	\draw [-] (3.south) -- (5.north);
	\node [below =1.5cm of 4, align=center] {\textbf{\underline{neighborhood structure}}};
\end{tikzpicture}\end{minipage} \end{center} 

\subsubsection*{2. Stochastic methods}
\noindent \textbf{\underline{Stochastic}} $\equiv$ probabilistic\\
A common approach is \textbf{\underline{simulated annealing}}\\
While not at goal:\\
\indent pick a neighbor randomly\\
\indent if it is better, go there\\
\indent else, there is a \% chance based on how much worse it is and the depth of the neighbor\\
End\\
\\
By exploring less when deeper, we can avoid local extrema and have a complete algorithm\\ 
\indent (provided we allow the algorithm to run for infinite time).\\


\subsection*{Compiling Sentences To Tractable Circuits}
\noindent Circuits are more compact than formulas, since circuits can reuse components!\\
\begin{center} \begin{circuitikz} 
	% circuit 1
		\node [rectangle, draw] at (0, 0) (A) {A};
		\node [rectangle, draw] at (0, 2) (B) {B};
		\node [rectangle, draw] at (0, 4) (C) {C};
		\draw node[and port] at (4, 1) (AND1) {};
		\draw node[not port] at (1.5, 2.5) (NOT){};
		\draw node[and port] at (4, 3) (AND2) {};
		\draw node[and port] at (6.5, 2) (OR) {};	
		\draw (A.east) -- (AND1.in 2);
		\draw (B.east) -- (AND1.in 1);
		\draw (B.east) -- (NOT.in);
		\draw (NOT.east) -- (AND2.in 2);
		\draw (C.east) -- (AND2.in 1);		
		\draw (AND1.out) -- (OR.in 2);
		\draw (AND2.out) -- (OR.in 1);
		\node [below =0.5cm of A] {DNF $(A \land \neg B) \lor (B \land C)$};
	% circuit 2
		\node [rectangle, draw] at (8, 0) (A) {A};
		\node [rectangle, draw] at (8, 1.33) (B) {C};
		\node [rectangle, draw] at (8, 2.66) (C) {B};
		\node [rectangle, draw] at (8, 4) (D) {$\bar D$};
		\draw node[or port] at (10, .666) (OR1) {};
		\draw node[or port] at (10, 3.33) (OR2) {};
		\draw node[and port] at (12.5, 2) (AND) {};	
		\draw (A.east) -- (OR1.in 2);
		\draw (B.east) -- (OR1.in 1);
		\draw (C.east) -- (OR2.in 2);
		\draw (D.east) -- (OR2.in 1);
		\draw (OR1.out) -- (AND.in 2);
		\draw (OR2.out) -- (AND.in 1);
		\node [below =0.5cm of A] {CNF $(A \lor C) \land (B \lor \neg D)$};
\end{circuitikz} \end{center}

\noindent It therefore makes sense to use them to express complicated logic.\\

\subsubsection*{Tractable NNF Circuits}
\noindent NNF circuits are not inherently tractable, but they are given certain restrictions.\\
\\
If the sub-circuits of all AND gates in a circuit share no variables, we say it is \textbf{\underline{decomposable}}\\
This property allows us to solve components of the circuit separately.\\
	\indent an AND gate is satisfiable iff all its sub-circuits are\\
	\indent an OR gate is satisfiable iff one of its sub-circuits are\\
If the circuit is decomposable, The circuit is tractable for SAT.\\
\\
If the inputs to an OR gate are mutually exclusive, we say it is \textbf{\underline{deterministic}}.\\
If a circuit is decomposable and deterministic, it is a d-DNNF circuit.\\
\indent d-DNNF circuits are tractable for \#SAT (“sharp-SAT”).\\
\indent \indent \#SAT counts the number of satisfying assignments in linear time.\\

\noindent If all sub-circuits of an OR gate share all variables, the gate is said to be \textbf{\underline{smooth}}.\\
\indent These can be easier to work with, but are logically equivalent to d-DNNFs.\\
\\
Complexity:
\begin{itemize} [itemsep=0mm]
	\item SAT is NP complete
	        $\equiv$ it is not thought to be solvable in polynomial time
	\item \#SAT is \#P complete
		$\equiv$it involves counting the number of acceptable NP solutions
	\item Maj-SAT is PP complete 
		$\equiv$ a probabilistic algorithm is run a set \# of times for a polynomial time 
\end{itemize}
\noindent While these methods are increasingly comple, they all can repeat information over time or space.\\
We address a solution to this issue in the next lecture.

\end{document}