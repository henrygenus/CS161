\documentclass[../../lecture_notes.tex]{subfiles}

\begin{document}

\noindent TERMINOLOGY:
\begin{itemize} [itemsep=0mm]
	\item A \textbf{\underline{node}} in a graph represents state, parent, action, and path-cost.
	\item \textbf{\underline{Expanding}} a node involved \textbf{\underline{generating}} children \& a goal test.
	\item The \textbf{\underline{fringe/frontier}} is the set of reachable nodes yet to be expanded.
	\item We define a \textbf{\underline{strategy}} as the criteria for choosing the next node to expand.
\end{itemize} \medskip
	
To decide on a search strategy, we need some criteria to evaluate them.\\
\indent We have four major criteria:
	\begin{enumerate} [itemsep=0mm]
		\item \textbf{\underline{completeness}}: does it find a solution (if one exists)?
		\item \textbf{\underline{optimality}}: does it always find the best solution?
		\item \textbf{\underline{time complexity}}: number of worst case nodes expanded
		\item \textbf{\underline{space complexity}}: maximum number of nodes stored in memory
	\end{enumerate}
\noindent What do we use to measure these?
	\begin{itemize}
		\item b -- max branching factor
		\item d -- depth of least cost solution
		\item m -- max depth of trees
	\end{itemize}
Let’s consider our two basic search algorithms:

\subsection*{Breadth-First Search}

\begin{tikzpicture}
\node [circle, draw] (tree) {A}
	child {node [circle, draw] {B}
		child {node [circle, draw] {D}
			edge from parent node {}
		}
		child {node {E}
			edge from parent node {}
		}
		edge from parent node {}
	}
	child[missing]
	child {node [circle, draw] (C) {C}
		child {node {F}
			edge from parent node {}
		}
		child {node {G}
			edge from parent node {}
		}
	};
\node [align=left, right =of C] (Q) {Queue:\\A\\BC\\CDE\\DEFG\\EFGHI...};
\node [text width=3cm, right =of Q] {\begin{enumerate} [itemsep=0mm] 
							\item Complete? Yes
							\item Optimal? Yes
							\item Time? $O(b^d)$ 
							\item Space? $O(b^d)$ 
						\end{enumerate}};
\end{tikzpicture} 

\subsection*{Depth-First Search}
\begin{tikzpicture}
\node [circle, draw] (tree) {A}
	child {node [circle, draw] {B}
		child {node [circle, draw] {D}
			edge from parent node {}
		}
		child {node [circle, draw] {E}
			edge from parent node {}
		}
		edge from parent node {}
	}
	child[missing]
	child {node (C) {C}
		child {node {F}
			edge from parent node {}
		}
		child {node {G}
			edge from parent node {}
		}
	};
\node [align=left, right =of C] (Q) {Stack:\\A\\CB\\CED\\CE...};
\node [text width=3cm, right =of Q]  {\begin{enumerate} [itemsep=0mm] 
							\item Complete? No
							\item Optimal? No
							\item Time? $O(b^d)$ 
							\item Space? $O(bm)$ 
						\end{enumerate}};
\end{tikzpicture} \medskip

\noindent We can’t seem to improve the time complexity, but can we improve by blending BFS \& DFS? \\
Consider a navigation problem:

\begin{center} \begin{tikzpicture}
	\node [rectangle, draw] (1) {};
	\node [rectangle, draw, below left =of 1] (2) {};
	\node [rectangle, draw, below right =of 2] (3) {};
	\node [rectangle, draw, below left =of 3] (4) {};
	\node [rectangle, draw, below right =of 4] (5) {};
	\node [rectangle, draw, above right =of 5] (6) {};
	\node [circle, draw, below right =of 6] (7) {};
	\node [rectangle, draw, right =4cm of 3] (9) {};
	\node [rectangle, draw, above right =of 9] (10) {};
	\draw [-] (1.south) -- (2.north);
	\draw [-] (1.south) -- (3.north);
	\draw [-] (2.south) -- (4.north);
	\draw [-] (3.west) -- (4.east);
	\draw [-] (4.south) -- (5.north);
	\draw [-] (5.north) -- (6.west);
	\draw [-] (6.east) -- (7.north west);
	\draw [-] (7.north east) -- (9.south);
	\draw [-] (3.east) -- (9.west);
	\draw [-] (10.south) -- (9.north);
\end{tikzpicture} \end{center}

\noindent We can see there are only 9 locations, so we can limit our path length! \\
We can use this to define a new algorithm:

\subsection*{Limited-Depth Search}
\noindent w/ length cutoff L, using priority queue (early = high priority)
\begin{enumerate} [itemsep=0mm]
	\item complete? No
	\item optimal? No
	\item time? O($b^L$)
	\item space? O(bL)
\end{enumerate}

\noindent We can extend this iteratively, increasing the length each round, for:
\subsection*{Iterative Deepening}
where L denotes the iterative length. \medskip

\begin{tikzpicture}
	\node (1) {A};
	 \node [right=2cm of 1] (2) {A}
		child {node {B} edge from parent {}}
		child {node {C} edge from parent {}};
	\node [right =2cm of 2] (3) {A} 
		child {node {B} 
			child {node {D} edge from parent {}}
			child {node {E} edge from parent {}}
			edge from parent {}
		}
	child {node {C} edge from parent {}}; 
	\node [below right =1cm of 3, text width=3cm] {\begin{enumerate} [itemsep=0mm] 
							\item Complete? No
							\item Optimal? No
							\item Time? $O(b^l)$ 
							\item Space? $O(bl)$ 
						\end{enumerate}};
	\draw [->] (1.north) -- node [align=center, above] {time} (3.north);
\end{tikzpicture}

But shouldn't we expect the time complexity to increase from limited-depth search?\\
\begin{equation*} t = b^0 (\frac {b} {b-1}) + b^1(\frac {b} {b-1}) + ... + b^d(\frac {b} {b-1}) \end{equation*}
\begin{align*} \text{Constant}
	&= (b=2) \to 2\\
	&= (b=3) \to 1.5\\
	&= (b=10) \to 1.1\\
\text{Therefore } & \text{the constant approaches 1!}
\end{align*}


\end{document}